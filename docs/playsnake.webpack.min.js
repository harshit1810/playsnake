/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_snake_food__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/snake-food */ "./modules/snake-food.js");
/* harmony import */ var _modules_snake_bonus_food__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/snake-bonus-food */ "./modules/snake-bonus-food.js");
/* harmony import */ var _modules_snake__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/snake */ "./modules/snake.js");




const PLAY_SNAKE = (ARENA_WIDTH = 500, ARENA_HEIGHT = 500) => {

    if (!window) {
        return;
    }
    const ERROR_MESSAGES = {
        DEFAULT: 'Sorry.',
        START_GAME: 'Sorry. Unable To Start The Game'
    };
    [
        ARENA_WIDTH,
        ARENA_HEIGHT
    ] = [
            parseInt(String(ARENA_WIDTH).trim()),
            parseInt(String(ARENA_HEIGHT).trim())
        ];

    const CONFIG_ARENA = {
        'id': 'play-snake-arena',
        'width': ARENA_WIDTH,
        'height': ARENA_HEIGHT,
        'borderColor': 'black',
        'borderWidth': 1,
        'limits': {
            'x': ARENA_WIDTH - 1,
            'y': ARENA_HEIGHT - 1
        },
        'supportedKeys': [37, 38, 39, 40],
        'keyConfig': {
            '37': {
                'reverse': 39
            },
            '38': {
                'reverse': 40
            },
            '39': {
                'reverse': 37
            },
            '40': {
                'reverse': 38
            }
        },
        'pauseButton': {
            'id': 'pause-play-snake',
            'text': 'Pause',
            'order': '0',
            'clickHandler': function (event) {
                game.stop();
                PAUSE_BUTTON.setAttribute('disabled', 'true');
                if (PLAY_BUTTON.hasAttribute('disabled')) {
                    PLAY_BUTTON.removeAttribute('disabled');
                }
            }
        },
        'resumeButton': {
            'id': 'resume-play-snake',
            'text': 'Resume',
            'order': '1',
            'clickHandler': function (event) {
                game.resume()
                PLAY_BUTTON.setAttribute('disabled', 'true');
                if (PAUSE_BUTTON.hasAttribute('disabled')) {
                    PAUSE_BUTTON.removeAttribute('disabled');
                }
            }
        }
    };



    class Subject {
        constructor(topic, observers = []) {
            this.observers = observers; // list of snake parts
            this.topic = topic;
        }
        addObserver(obsrv) {
            if (obsrv.element && obsrv.element.id) {
                this.observers.push(obsrv);
            }
        }
        removeObserver(obsrv) {
            this.observers.splice(
                this.observers.findIndex(obj => obj.element.id === obsrv.element.id), 1
            );
        }
        notify() {
            this.observers.forEach(obsrv => {
                obsrv[this.topic](); // call the topic for each snake part
            });
        }
    }
    class SnakeNotifier extends Subject {
        constructor() {
            super('nextXY');
        }
        notify(foodEaten) {
            super.notify();
            if (!foodEaten) {
                return;
            }
            const food = UTILS.getSnakeFood();
            UTILS.getSnake().grow(food.drop.bind(food));
        }
    }

    const SNAKE_PART_POSITION_UPDATER = new SnakeNotifier();

    const UTILS = {
        RENDER_UNIT: 'px',
        getSvgNamespace: function () {
            return 'http://www.w3.org/2000/svg';
        },
        getWindow: function () {
            return window;
        },
        getDocument: function () {
            return this.getWindow().document;
        },
        getDocumentBody: function () {
            return this.getDocument().body;
        },
        showAlert: function (message) {
            this.getWindow().alert(message);
        },
        getArena: function () {
            return SNAKE_ARENA;
        },
        getArenaConfig: function () {
            return CONFIG_ARENA;
        },
        getSnake: function () {
            return game.getSnake();
        },
        getSnakeFood: function () {
            return game.getSnakeFood();
        },
        getSnakeBonusFood: function () {
            return game.getSnakeBonusFood();
        },
        getDirectionCommands: function () {
            return COMMAND_STACK;
        },
        getSnakeDirectionMap: function () {
            return SNAKE_DIRECTION_MAP;
        },
        pixelify: function (number) {
            return String(number).trim().concat(this.RENDER_UNIT);
        },
        getPositionUpdater: function () {
            return SNAKE_PART_POSITION_UPDATER;
        },
        incrementScore: function (points) {
            SCORE_BOARD.innerHTML = +SCORE_BOARD.innerHTML + points;
        },
        getStyleString: function (obj = {}) {
            return Object.keys(obj).reduce((str, key) => {
                if (!key || !String(key).trim().length) {
                    return str;
                }
                key = String(key).trim();
                let value = obj[key];
                if (!String(value).trim().length) {
                    return str;
                }
                value = String(value).trim();
                return str.concat(` ${key}: ${value};`);
            }, '');
        },
        createHTMLElement: function ({ elementType, innerHTML, attributes = {}, eventListeners = {}, elementNamespace, parent, beforeElement }) {
            if (!parent) {
                parent = UTILS.getDocumentBody();
            }

            const element = elementNamespace ?
                this.getDocument().createElementNS(elementNamespace, elementType) :
                this.getDocument().createElement(elementType);

            if (typeof attributes === 'object') {
                Object.keys(attributes).forEach(key => element.setAttribute(key, attributes[key]));
            }
            innerHTML ? element.innerHTML = String(innerHTML) : undefined;

            if (beforeElement) {
                parent.insertBefore(element, beforeElement);
            } else {
                parent.appendChild(element);
            }

            if (typeof eventListeners === 'object') {
                Object.keys(eventListeners).forEach(eventName => element.addEventListener(eventName, eventListeners[eventName]));
            }

            return element;
        },
        LOGGER: {
            log: console.log,
            error: console.error,
            warn: console.warn
        }
    };

    const { SNAKE_ARENA, PLAY_BUTTON, PAUSE_BUTTON, SCORE_BOARD } = (function init() {
        try {
            UTILS.getDocumentBody().style.fontFamily = 'Candara';
            const gameControlDiv = UTILS.createHTMLElement({
                elementType: 'div',
                attributes: {
                    style: UTILS.getStyleString({
                        display: 'flex',
                        'flex-direction': 'row',
                        'flex-wrap': 'nowrap',
                        width: UTILS.pixelify(CONFIG_ARENA.width),
                        padding: '1% 0%'
                    })
                }
            });

            const styleString = UTILS.getStyleString({
                padding: '2% 2%',
                'border-radius': '5px',
                flex: '0 1 20%',
                'text-align': 'center',
                'align-self': 'flex-end'
            });

            const pauseBtn = UTILS.createHTMLElement({
                elementType: 'button',
                parent: gameControlDiv,
                innerHTML: CONFIG_ARENA.pauseButton.text,
                attributes: {
                    id: CONFIG_ARENA.pauseButton.id,
                    style: `${styleString} order: ${CONFIG_ARENA.pauseButton.order}`
                },
                eventListeners: {
                    click: CONFIG_ARENA.pauseButton.clickHandler
                }
            });

            const playBtn = UTILS.createHTMLElement({
                elementType: 'button',
                parent: gameControlDiv,
                innerHTML: CONFIG_ARENA.resumeButton.text,
                attributes: {
                    id: CONFIG_ARENA.resumeButton.id,
                    style: `${styleString} margin-left: 2%; order: ${CONFIG_ARENA.resumeButton.order}`
                },
                eventListeners: {
                    click: CONFIG_ARENA.resumeButton.clickHandler
                }
            });

            const arenaContainer = UTILS.createHTMLElement({
                elementType: 'div',
                attributes: {
                    id: 'arena-container',
                    style: UTILS.getStyleString({
                        display: 'flex',
                        'flex-direction': 'cols',
                        'flex-wrap': 'wrap',
                    })
                }
            });
            const canvas = UTILS.createHTMLElement({
                elementNamespace: UTILS.getSvgNamespace(),
                elementType: 'svg',
                attributes: {
                    id: CONFIG_ARENA.id,
                    height: CONFIG_ARENA.height,
                    width: CONFIG_ARENA.width,
                    style: `border: ${UTILS.pixelify(CONFIG_ARENA.borderWidth)} solid ${CONFIG_ARENA.borderColor}`
                },
                parent: arenaContainer
            });

            const legendContainer = UTILS.createHTMLElement({
                elementType: 'div',
                parent: arenaContainer,
                attributes: {
                    id: 'legend-container',
                    style: UTILS.getStyleString({
                        padding: '2px 2px'
                    })
                }
            });
            UTILS.createHTMLElement({
                parent: legendContainer,
                elementType: 'div',
                innerHTML: 'Speed Powerup'
            });
            UTILS.createHTMLElement({
                parent: legendContainer,
                elementType: 'div',
                innerHTML: 'Bonus 10 points'
            });
            UTILS.createHTMLElement({
                parent: legendContainer,
                elementType: 'div',
                innerHTML: '5 points'
            });

            const scoreContainer = UTILS.createHTMLElement({
                elementType: 'div',
                innerHTML: 'Your Score: '
            });
            const scoreSpan = UTILS.createHTMLElement({
                elementType: 'span',
                parent: scoreContainer,
                attributes: {
                    id: 'score',
                    style: UTILS.getStyleString({
                        'font-weight': 'bold'
                    })
                },
                innerHTML: '0'
            });

            return {
                SNAKE_ARENA: canvas,
                PLAY_BUTTON: playBtn,
                PAUSE_BUTTON: pauseBtn,
                SCORE_BOARD: scoreSpan
            };
        } catch (e) {
            UTILS.LOGGER.error(e);
        }
    })();

    if (!SNAKE_ARENA) {
        return UTILS.showAlert('Sorry. Unable to start the game.');
    }

    let SNAKE_BONUS_FOOD;
    /**
     * configurations
     */
    const CONFIG = (function (arg) {
        return {
            SNAKE: {
                id: arg.snakeId,
                elemType: 'rect',
                width: arg.snakeSize,
                color: arg.primaryColor,
                length: arg.snakeLength,
                speed: arg.snakeSpeed,
                directionMap: {
                    '37': 'LEFT',
                    '38': 'UP',
                    '39': 'RIGHT',
                    '40': 'DOWN'
                },
                step: 1
            },
            SNAKE_PART: {
                'idPrefix': arg.snakeId + '-part'
            },
            SNAKE_FOOD: {
                'id': arg.snakeFoodId,
                'elemType': 'circle',
                'color': arg.secondaryColor,
                'size': Math.floor(arg.snakeSize / 3),
                'startAfter': 2,
                'limits': {
                    'x': CONFIG_ARENA.limits.x - arg.snakeSize,
                    'y': CONFIG_ARENA.limits.y - arg.snakeSize
                },
                'points': arg.foodPoints
            },
            SNAKE_BONUS_FOOD: {
                'id': arg.snakeBonusFoodId,
                'color': arg.alertColor,
                'elemType': 'circle',
                'size': arg.snakeSize,
                'startAfter': 30,
                'limits': {
                    'x': CONFIG_ARENA.limits.x - (arg.snakeSize * 2),
                    'y': CONFIG_ARENA.limits.y - (arg.snakeSize * 2)
                },
                'points': arg.bonusFoodPoints,
                'duration': 10
            },
            ARENA: {
                center: {
                    x: Math.floor(Math.floor(SNAKE_ARENA.getAttribute('width')) / 2),
                    y: Math.floor(Math.floor(SNAKE_ARENA.getAttribute('height')) / 2)
                }
            }
        };
    })({
        snakeId: 'the-snake',
        snakeFoodId: 'the-snake-food',
        snakeBonusFoodId: 'the-snake-bonus-food',
        snakeSpeed: 20,
        primaryColor: 'black',
        secondaryColor: 'grey',
        alertColor: 'red',
        snakeLength: 1,
        snakeSize: 15,
        foodPoints: 5,
        bonusFoodPoints: 10
    });
    let SNAKE_DIRECTION = 39;

    /**
     * store the directions given to the snake
     */
    const COMMAND_STACK = (initCommand => {
        const commands = [];
        if (initCommand) {
            commands.push(initCommand);
        }
        return {
            add: function (data) {
                let last = commands[commands.length - 1];
                if (!last) {
                    commands.push(data);
                    return;
                }
                if (last.position.x == data.position.x && last.position.y == data.position.y) {
                    last.direction = data.direction;
                } else {
                    commands.push(data);
                }
            },
            getFirst: function () {
                return commands[0];
            },
            remove: function () {
                commands.shift();
                return;
            },
            clear: function () {
                commands.splice(0, commands.length);
                return;
            },
            hasCommands: function () {
                return commands.length > 0 ? true : false;
            },
            getNextTurn: function (snakePartId) {
                if (typeof SNAKE_DIRECTION_MAP[snakePartId] === 'undefined') {
                    return this.getFirst();
                }
                let turnMadeIndex = commands.findIndex(com => com.id === SNAKE_DIRECTION_MAP[snakePartId]);
                return (turnMadeIndex == commands.length - 1) ? undefined : commands[turnMadeIndex + 1];
            }
        };
    })({
        id: Date.now(),
        direction: SNAKE_DIRECTION,
        position: {
            x: CONFIG.ARENA.center.x,
            y: CONFIG.ARENA.center.y
        }
    });

    const SNAKE_DIRECTION_MAP = {};

    const { Snake } = Object(_modules_snake__WEBPACK_IMPORTED_MODULE_2__["default"])(CONFIG, UTILS);
    const SnakeFoodClass = Object(_modules_snake_food__WEBPACK_IMPORTED_MODULE_0__["default"])(CONFIG, UTILS);
    const SnakeFoodBonusClass = Object(_modules_snake_bonus_food__WEBPACK_IMPORTED_MODULE_1__["default"])(CONFIG, UTILS);

    class PlaySnakeGame {
        constructor(arena) {
            this.intervals = [];
            this.timers = [];
            this._snake;
            this._snakeFood;
            this._snakeBonusFood;
            this.snakeDirection;
            this.arena = arena;
            this.snakeSpeed = 20;
        }

        getSnake() {
            if (this._snake instanceof Snake) {
                return this._snake;
            }
            const { direction, position: { x, y } } = COMMAND_STACK.getFirst();
            this.snakeDirection = direction;
            this._snake = new Snake(
                this.arena,
                x,
                y,
                this.snakeDirection,
                this.snakeSpeed
            );
            return this._snake;
        }

        getSnakeFood() {
            if (this._snakeFood instanceof SnakeFoodClass) {
                return this._snakeFood;
            }
            const { x, y } = SnakeFoodClass.getNextFoodPosition();
            this._snakeFood = new SnakeFoodClass(this.arena, x, y);
            return this._snakeFood;
        }

        getSnakeBonusFood() {
            if (this._snakeBonusFood instanceof SnakeFoodBonusClass) {
                return this._snakeBonusFood;
            }
            const { x, y } = SnakeFoodBonusClass.getNextFoodPosition();
            this._snakeBonusFood = new SnakeFoodBonusClass(
                this.arena, x, y
            );
            return this._snakeBonusFood;
        }

        start() {
            try {
                this.getSnake();
                const food = this.getSnakeFood();
                setTimeout(CONFIG.SNAKE_FOOD.startAfter * 1000, food);
                const bonusFood = this.getSnakeBonusFood();
                this.intervals.push(bonusFood.startBonusFood());
                this.setButtonListeners();
                this.intervals.push(this.getSnake().startSnake());
            } catch (error) {
                UTILS.showAlert(ERROR_MESSAGES.START_GAME);
            }
        }

        pause() {

        }

        async stop() {
            this._snake = null;
            UTILS.getWindow().clearInterval(this.getSnake().intervalId);
            const { intervalId: bonusFoodInterval } = this.getSnakeBonusFood();
            UTILS.getWindow().clearInterval(bonusFoodInterval);
            this._snakeFood = null;
            this._snakeBonusFood = null;
            UTILS.getWindow().alert('GAME OVER\nYou Scored ' + SCORE_BOARD.innerHTML + ' points.');
        }

        async resume() {
            const bonusFoodIntervalId = this.getSnakeBonusFood().startBonusFood();
            this.intervals.push(bonusFoodIntervalId);
            this.intervals.push(this.getSnake().startSnake());
            LOGGER.log('game resumed');
        }

        setButtonListeners() {
            UTILS.getWindow().addEventListener('unload', this.stop);
            UTILS.getDocument().addEventListener('keydown', event => {
                /** listen only for direction keys */
                if (CONFIG_ARENA.supportedKeys.indexOf(event.keyCode) === -1) {
                    return;
                }
                /**
                 * the new direction should not be the current direction 
                 * or the opposite direction.
                 */
                if (SNAKE_DIRECTION == event.keyCode &&
                    event.keyCode == CONFIG_ARENA.keyConfig[String(SNAKE_DIRECTION)].reverse) {
                    return;
                }
                SNAKE_DIRECTION = event.keyCode;
                this.snakeDirection = event.keyCode;
                this.getSnake().currentDirection = this.snakeDirection;
                COMMAND_STACK.add({
                    id: Date.now(),
                    direction: event.keyCode,
                    position: {
                        x: UTILS.getSnake().head.x,
                        y: UTILS.getSnake().head.y
                    }
                });
            });
        }

        increaseSnakeSpeed() {
            UTILS.getWindow().clearInterval(this.getSnake().intervalId);
            startSnake(CONFIG.SNAKE.speed - UTILS.getSnake().length * 50);
        }
    }

    const game = new PlaySnakeGame(SNAKE_ARENA);

    game.start();
};

PLAY_SNAKE();

/***/ }),

/***/ "./modules/snake-bonus-food.js":
/*!*************************************!*\
  !*** ./modules/snake-bonus-food.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (config, utils) {
    return class SnakeFoodBonus {
        constructor(arena, cx, cy, color = config.SNAKE_BONUS_FOOD.color, size = config.SNAKE_BONUS_FOOD.size) {
            this.element = utils.createHTMLElement({
                elementNamespace: utils.getSvgNamespace(),
                elementType: config.SNAKE_BONUS_FOOD.elemType,
                beforeElement: utils.getSnake().head.element,
                parent: utils.getArena(),
                attributes: {
                    id: config.SNAKE_BONUS_FOOD.id,
                    cx,
                    cy,
                    r: size,
                    fill: color
                }
            });
            this.arena = arena;
            [this.x2, this.y2] = [cx + (config.SNAKE_BONUS_FOOD.size - 1), cy + (config.SNAKE_BONUS_FOOD.size - 1)];
            this.intervalId;
        }
        startBonusFood() {
            this.intervalId = setInterval(
                () => { this.drop(); },
                config.SNAKE_BONUS_FOOD.startAfter * 1000
            );
            return this.intervalId;
        }
        get x() {
            return parseInt(this.element.getAttribute('cx'));
        }
        set x(value) {
            this.element.setAttribute('cx', Math.floor(value));
        }
        get y() {
            return parseInt(this.element.getAttribute('cy'));
        }
        set y(value) {
            this.element.setAttribute('cy', Math.floor(value));
        }
        static getNextFoodPosition() {
            function getRandomX() {
                return Math.floor(Math.random() * (config.SNAKE_BONUS_FOOD.limits.x - config.SNAKE_BONUS_FOOD.size)) + utils.getArenaConfig().borderWidth + 1;
            }
            function getRandomY() {
                return Math.floor(Math.random() * (config.SNAKE_BONUS_FOOD.limits.y - config.SNAKE_BONUS_FOOD.size)) + utils.getArenaConfig().borderWidth + 1;
            }
            // return new Promise(function (resolve, reject) {
            let _x, _y;
            const snakeWidth = config.SNAKE.width;
            // let interval;
            do {
                [_x, _y] = [getRandomX(), getRandomY()];
            } while (_x % snakeWidth !== 0 && _y % snakeWidth !== 0);
            return { x: _x + 2, y: _y + 2 };
            // interval = setInterval(function (multipleOf, res, rej) {
            //     try {
            //         if (_x % multipleOf === 0 && _y % multipleOf === 0) {
            //             utils.getWindow().clearInterval(interval);
            //             res({
            //                 x: _x + 2, y: _y + 2
            //             });
            //         } else {
            //             [_x, _y] = [getRandomX(), getRandomY()];
            //         }
            //     } catch (e) {
            //         reject(e);
            //     }

            // }, 0, config.SNAKE.width, resolve, reject);
            // });
        }
        async drop() {
            const { x, y } = await SnakeFoodBonus.getNextFoodPosition();
            this.x = x;
            this.y = y;
            // start timer to hide bonus food
            setTimeout(() => { this.hide(); }, config.SNAKE_BONUS_FOOD.duration * 1000);
        }
        hide() {
            this.x = -100;
            this.y = -100;
        }
    }
});;

/***/ }),

/***/ "./modules/snake-food.js":
/*!*******************************!*\
  !*** ./modules/snake-food.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (config, utils) {
    return class SnakeFood {
        constructor(arena, cx, cy, color = config.SNAKE_FOOD.color, size = config.SNAKE_FOOD.size) {

            this.element = utils.createHTMLElement({
                elementType: config.SNAKE_FOOD.elemType,
                elementNamespace: utils.getSvgNamespace(),
                attributes: {
                    id: config.SNAKE_FOOD.id,
                    cx,
                    cy,
                    r: size,
                    fill: color
                },
                parent: utils.getArena(),
                beforeElement: utils.getSnake().head.element
            });
            this.arena = arena;
            [this.x2, this.y2] = [cx + (config.SNAKE_FOOD.size - 1), cy + (config.SNAKE_FOOD.size - 1)];
        }
        static getNextFoodPosition() {
            function getRandomX() {
                return Math.floor(Math.random() * (config.SNAKE_FOOD.limits.x - config.SNAKE_FOOD.size)) + utils.getArenaConfig().borderWidth + 1;
            }
            function getRandomY() {
                return Math.floor(Math.random() * (config.SNAKE_FOOD.limits.y - config.SNAKE_FOOD.size)) + utils.getArenaConfig().borderWidth + 1;
            }
            let _x, _y;
            const snakeWidth = config.SNAKE.width;
            do {
                [_x, _y] = [getRandomX(), getRandomY()];
            } while (_x % snakeWidth !== 0 && _y % snakeWidth !== 0);
            return {
                x: _x + 2,
                y: _y + 2
            };
            // return new Promise((resolve, reject) => {
            //     let [_x, _y] = [getRandomX(), getRandomY()];
            //     let interval;
            //     interval = setInterval(function (multipleOf, res, rej) {
            //         try {
            //             if (_x % multipleOf === 0 && _y % multipleOf === 0) {
            //                 utils.getWindow().clearInterval(interval);
            //                 res({
            //                     x: _x + 2,
            //                     y: _y + 2
            //                 });
            //             } else {
            //                 [_x, _y] = [getRandomX(), getRandomY()];
            //             }
            //         } catch (e) {
            //             reject(e);
            //         }

            //     }, 0, config.SNAKE.width, resolve, reject);
            // });
        }
        get x() {
            return parseInt(this.element.getAttribute('cx'));
        }
        set x(value) {
            this.element.setAttribute('cx', Math.floor(value));
        }
        get y() {
            return parseInt(this.element.getAttribute('cy'));
        }
        set y(value) {
            this.element.setAttribute('cy', Math.floor(value));
        }
        drop() {
            const { x, y } = SnakeFood.getNextFoodPosition();
            this.x = x;
            this.y = y;
        }
        hide() {
            this.x = -10;
            this.y = -10;
        }
    }
});;

/***/ }),

/***/ "./modules/snake.js":
/*!**************************!*\
  !*** ./modules/snake.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (config, utils) {

    class Snake {
        constructor(arena, startX, startY, direction, speed, color = config.SNAKE.color) {
            this.length = 1;
            this.head = new SnakePart(arena, startX, startY, direction, this.length, color);
            this.tail = this.head;
            this.arena = arena;
            this.speed = speed;
            this.UP = function () {
                this.move(0, config.SNAKE.step * -1);
            };
            this.DOWN = function () {
                this.move(0, config.SNAKE.step);
            };
            this.RIGHT = function () {
                this.move(config.SNAKE.step, 0);
            };
            this.LEFT = function () {
                this.move(config.SNAKE.step * -1, 0);
            };
            this.turningPoints = [];
            this.intervalId;
            this.currentDirection = direction;
        }
        startSnake() {
            this.intervalId = setInterval(() => {
                this.changeDirection(this.currentDirection);
                this.start();
            }, this.speed);
            return this.intervalId;
        }
        changeDirection(newDirection) {
            this.head.direction = newDirection;
        }
        /**
         * adds a snake part at the tail
         * @param {function} next a callback
         * @returns undefined
         */
        grow(next) {
            const { x, y } = this.tail.getXYOfNextPart();
            this.length += 1;
            const newPart = new SnakePart(this.arena, x, y, this.tail.direction, this.length, this.tail.color);
            this.tail.next = newPart;
            newPart.prev = this.tail;
            this.tail = newPart;
            utils.getPositionUpdater().addObserver(this.tail);
            utils.incrementScore(config.SNAKE_FOOD.points);
            // drop food pellet
            if (typeof next === 'function') {
                next();
            }
        }
        changeColor(colour) {
            let _part = this.head;
            while (_part.next !== null) {
                change(_part, colour);
                _part = _part.next;
            }

            function change(_part, clr) {
                setTimeout(() => {
                    _part.color = clr;
                }, 0);
            }
        }
        start() {
            this[config.SNAKE.directionMap[String(this.head.direction)]]();
        }
        isEatingFood() {
            const food = utils.getSnakeFood();
            const { x: foodX, y: foodY } = food;
            if (this.head.x < foodX
                && foodX < this.head.x2
                && this.head.y < foodY
                && foodY < this.head.y2) {
                food.hide();
                return true;
            }
            return false;
        }
        isEatingBonusFood() {
            const bonusFoodSize = config.SNAKE_BONUS_FOOD.size;
            const head = this.head;
            const { x: bonusFoodX, y: bonusFoodY } = utils.getSnakeBonusFood();
            let x1 = bonusFoodX - bonusFoodSize - 1;
            let x2 = bonusFoodX + bonusFoodSize - 1;
            let y1 = bonusFoodY - bonusFoodSize - 1;
            let y2 = bonusFoodY + bonusFoodSize - 1;
            if (x1 < head.x && head.x < x2 && y1 < head.y && head.y < y2) {
                return true;
            }
            return false;
        }
        move(xvalue, yvalue) {
            let _part = this.head;
            let [_part_x_pos, _part_y_pos] = [_part.x, _part.y];
            let { x: nextX, y: nextY } = SnakePart.checkBoundaryPosition(_part.direction, {
                'x': _part_x_pos + xvalue,
                'y': _part_y_pos + yvalue
            });
            const isGoingToEatSelf = this.isEatingItself();
            if (isGoingToEatSelf) {
                utils.LOGGER.warn('You ate yourself');
                stopTheGame();
                return;
            }
            _part.x = nextX;
            _part.y = nextY;
            const isEatingFood = this.isEatingFood();
            const isEatingBonusFood = this.isEatingBonusFood();
            if (isEatingBonusFood) {
                utils.getSnakeBonusFood().hide();
                utils.incrementScore(config.SNAKE_BONUS_FOOD.points);
            }
            this.moveAllParts(isEatingFood);
        }
        moveAllParts(foodEaten) {
            if (this.length === 1) {
                utils.getDirectionCommands().clear();
            }
            utils.getPositionUpdater().notify(foodEaten);
        }
        /**
         * @returns {boolean} indicates wether the snake is going to eat itself
         */
        isEatingItself() {
            let isGoingToEat = false;
            let nextPart = this.head.next;
            let snakeDirection = this.head.direction;
            while (nextPart !== null) {
                // check for tail node and nodes which are traveliing in different direction than the head
                if (nextPart.direction !== snakeDirection || nextPart.id === this.tail.id) {
                    switch (snakeDirection) {
                        case 37:
                            if (this.head.y === nextPart.y && this.head.x > nextPart.x && this.head.x <= nextPart.x2) {
                                isGoingToEat = true;
                            }
                            break;
                        case 38:
                            if (this.head.x === nextPart.x && this.head.y > nextPart.y && this.head.y <= nextPart.y2) {
                                isGoingToEat = true;
                            }
                            break;
                        case 39:
                            if (this.head.y === nextPart.y && this.head.x2 < nextPart.x2 && this.head.x2 >= nextPart.x) {
                                isGoingToEat = true;
                            }
                            break;
                        case 40:
                            if (this.head.x === nextPart.x && this.head.y2 < nextPart.y2 && this.head.y2 >= nextPart.y) {
                                isGoingToEat = true;
                            }
                            break;
                    }
                    if (isGoingToEat) {
                        break;
                    }
                }
                nextPart = nextPart.next;
            }
            if (isGoingToEat) {
                return true;
            }
            return false;
        }
    };

    class SnakePart {
        constructor(arena, x, y, dirx, partNumber, color) {
            this.id = `${config.SNAKE.id}-part${partNumber}`;
            this.direction = dirx;
            this.element = utils.createHTMLElement({
                elementNamespace: utils.getSvgNamespace(),
                elementType: config.SNAKE.elemType,
                attributes: {
                    id: this.id,
                    tabIndex: partNumber,
                    x,
                    y,
                    rx: config.SNAKE.width,
                    ry: config.SNAKE.width,
                    fill: color,
                    width: utils.pixelify(config.SNAKE.width),
                    height: utils.pixelify(config.SNAKE.width)
                },
                parent: arena
            });
            this.color = color;
            this.next = null;
            this.prev = null;
        }
        isSnakeHead() {
            return this.id === config.SNAKE.id;
        }
        get x() {
            return parseInt(this.element.getAttribute('x'));
        }
        set x(value) {
            this.element.setAttribute('x', Math.floor(value));
        }
        get y() {
            return parseInt(this.element.getAttribute('y'));
        }
        set y(value) {
            this.element.setAttribute('y', Math.floor(value));
        }
        get x2() {
            return this.x + (config.SNAKE.width - 1);
        }
        get y2() {
            return this.y + (config.SNAKE.width - 1);
        }
        isTail() {
            return this.id === utils.getSnake().tail.id;
        }
		/**
		 * method calculates the next coordinates for a part on each step
		 */
        nextXY() {
            let nextPosition = {
                'x': this.x, 'y': this.y
            }
            switch (this.direction) {
                case 37:
                    nextPosition.x -= config.SNAKE.step;
                    break;
                case 38:
                    nextPosition.y -= config.SNAKE.step;
                    break;
                case 39:
                    nextPosition.x += config.SNAKE.step;
                    break;
                case 40:
                    nextPosition.y += config.SNAKE.step;
                    break;
            }
            nextPosition = SnakePart.checkBoundaryPosition(this.direction, nextPosition);
            this.x = nextPosition.x;
            this.y = nextPosition.y;
            if (utils.getDirectionCommands().hasCommands()) {
                let _command = utils.getDirectionCommands().getNextTurn(this.id);
                if (_command && _command.position.x == this.x && _command.position.y == this.y) {
                    this.direction = _command.direction;
                    (utils.getSnakeDirectionMap())[this.id] = _command.id;
                    if (this.isTail()) {
                        utils.getDirectionCommands().remove();
                    }
                }
            }
        }
        getXYOfNextPart() {
            let [_x, _y] = [this.x, this.y];
            switch (this.direction) {
                case 37:
                    _x += config.SNAKE.width;
                    break;
                case 38:
                    _y += config.SNAKE.width;
                    break;
                case 39:
                    _x -= config.SNAKE.width;
                    break;
                case 40:
                    _y -= config.SNAKE.width;
                    break;
            }
            return { x: _x, y: _y };
        }
		/**
		 * returns new coordinates if the snake part is going out of bounds.
		 * 
		 * @param {number} direction the current direction of the snake part.
		 * @param {object} position coordinates of the next step.
		 */
        static checkBoundaryPosition(direction, position) {
            switch (direction) {
                case 37:
                    if (position.x < utils.getArenaConfig().borderWidth) {
                        position.x = utils.getArenaConfig().limits.x - config.SNAKE.width;
                    }
                    break;
                case 38:
                    if (position.y < utils.getArenaConfig().borderWidth) {
                        position.y = utils.getArenaConfig().limits.y - config.SNAKE.width;
                    }
                    break;
                case 39:
                    if (position.x + config.SNAKE.width > utils.getArenaConfig().limits.x) {
                        position.x = utils.getArenaConfig().borderWidth;
                    }
                    break;
                case 40:
                    if (position.y + config.SNAKE.width > utils.getArenaConfig().limits.y) {
                        position.y = utils.getArenaConfig().borderWidth;
                    }
                    break;
            }
            return position;
        }
    }

    return {
        SnakePart,
        Snake
    };
});;

/***/ })

/******/ });
//# sourceMappingURL=playsnake.webpack.min.js.map