{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./index.js","webpack:///./modules/snake-bonus-food.js","webpack:///./modules/snake-food.js","webpack:///./modules/snake.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAmD;AACW;AACpB;;AAE1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI,IAAI,OAAO;AACrD,aAAa;AACb,SAAS;AACT,sCAAsC,wCAAwC,qBAAqB,2CAA2C;AAC9I;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,sDAAsD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY,UAAU,+BAA+B;AACnF,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY,iBAAiB,UAAU,gCAAgC;AACrG,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yCAAyC,SAAS,yBAAyB;AACjH,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA,WAAW,QAAQ,GAAG,8DAAW;AACjC,2BAA2B,mEAAe;AAC1C,gCAAgC,yEAAoB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB,OAAO,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,a;;;;;;;;;;;;AC3kBA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,wBAAwB;AACxB;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,8BAA8B,aAAa,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,G;;;;;;;;;;;;ACnFD;AAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,4BAA4B;AAC5B;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA,oBAAoB;AACpB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,G;;;;;;;;;;;;AC/ED;AAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,gBAAgB,OAAO,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,G","file":"playsnake.webpack.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","import SnakeFoodModule from './modules/snake-food';\r\nimport SnakeBonusFoodModule from './modules/snake-bonus-food';\r\nimport SnakeModule from './modules/snake';\r\n\r\nconst PLAY_SNAKE = (ARENA_WIDTH = 500, ARENA_HEIGHT = 500) => {\r\n\r\n    if (!window) {\r\n        return;\r\n    }\r\n    const ERROR_MESSAGES = {\r\n        DEFAULT: 'Sorry.',\r\n        START_GAME: 'Sorry. Unable To Start The Game'\r\n    };\r\n    [\r\n        ARENA_WIDTH,\r\n        ARENA_HEIGHT\r\n    ] = [\r\n            parseInt(String(ARENA_WIDTH).trim()),\r\n            parseInt(String(ARENA_HEIGHT).trim())\r\n        ];\r\n\r\n    const CONFIG_ARENA = {\r\n        'id': 'play-snake-arena',\r\n        'width': ARENA_WIDTH,\r\n        'height': ARENA_HEIGHT,\r\n        'borderColor': 'black',\r\n        'borderWidth': 1,\r\n        'limits': {\r\n            'x': ARENA_WIDTH - 1,\r\n            'y': ARENA_HEIGHT - 1\r\n        },\r\n        'supportedKeys': [37, 38, 39, 40],\r\n        'keyConfig': {\r\n            '37': {\r\n                'reverse': 39\r\n            },\r\n            '38': {\r\n                'reverse': 40\r\n            },\r\n            '39': {\r\n                'reverse': 37\r\n            },\r\n            '40': {\r\n                'reverse': 38\r\n            }\r\n        },\r\n        'pauseButton': {\r\n            'id': 'pause-play-snake',\r\n            'text': 'Pause',\r\n            'order': '0',\r\n            'clickHandler': function (event) {\r\n                game.stop();\r\n                PAUSE_BUTTON.setAttribute('disabled', 'true');\r\n                if (PLAY_BUTTON.hasAttribute('disabled')) {\r\n                    PLAY_BUTTON.removeAttribute('disabled');\r\n                }\r\n            }\r\n        },\r\n        'resumeButton': {\r\n            'id': 'resume-play-snake',\r\n            'text': 'Resume',\r\n            'order': '1',\r\n            'clickHandler': function (event) {\r\n                game.resume()\r\n                PLAY_BUTTON.setAttribute('disabled', 'true');\r\n                if (PAUSE_BUTTON.hasAttribute('disabled')) {\r\n                    PAUSE_BUTTON.removeAttribute('disabled');\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n\r\n    class Subject {\r\n        constructor(topic, observers = []) {\r\n            this.observers = observers; // list of snake parts\r\n            this.topic = topic;\r\n        }\r\n        addObserver(obsrv) {\r\n            if (obsrv.element && obsrv.element.id) {\r\n                this.observers.push(obsrv);\r\n            }\r\n        }\r\n        removeObserver(obsrv) {\r\n            this.observers.splice(\r\n                this.observers.findIndex(obj => obj.element.id === obsrv.element.id), 1\r\n            );\r\n        }\r\n        notify() {\r\n            this.observers.forEach(obsrv => {\r\n                obsrv[this.topic](); // call the topic for each snake part\r\n            });\r\n        }\r\n    }\r\n    class SnakeNotifier extends Subject {\r\n        constructor() {\r\n            super('nextXY');\r\n        }\r\n        notify(foodEaten) {\r\n            super.notify();\r\n            if (!foodEaten) {\r\n                return;\r\n            }\r\n            const food = UTILS.getSnakeFood();\r\n            UTILS.getSnake().grow(food.drop.bind(food));\r\n        }\r\n    }\r\n\r\n    const SNAKE_PART_POSITION_UPDATER = new SnakeNotifier();\r\n\r\n    const UTILS = {\r\n        RENDER_UNIT: 'px',\r\n        getSvgNamespace: function () {\r\n            return 'http://www.w3.org/2000/svg';\r\n        },\r\n        getWindow: function () {\r\n            return window;\r\n        },\r\n        getDocument: function () {\r\n            return this.getWindow().document;\r\n        },\r\n        getDocumentBody: function () {\r\n            return this.getDocument().body;\r\n        },\r\n        showAlert: function (message) {\r\n            this.getWindow().alert(message);\r\n        },\r\n        getArena: function () {\r\n            return SNAKE_ARENA;\r\n        },\r\n        getArenaConfig: function () {\r\n            return CONFIG_ARENA;\r\n        },\r\n        getSnake: function () {\r\n            return game.getSnake();\r\n        },\r\n        getSnakeFood: function () {\r\n            return game.getSnakeFood();\r\n        },\r\n        getSnakeBonusFood: function () {\r\n            return game.getSnakeBonusFood();\r\n        },\r\n        getDirectionCommands: function () {\r\n            return COMMAND_STACK;\r\n        },\r\n        getSnakeDirectionMap: function () {\r\n            return SNAKE_DIRECTION_MAP;\r\n        },\r\n        pixelify: function (number) {\r\n            return String(number).trim().concat(this.RENDER_UNIT);\r\n        },\r\n        getPositionUpdater: function () {\r\n            return SNAKE_PART_POSITION_UPDATER;\r\n        },\r\n        incrementScore: function (points) {\r\n            SCORE_BOARD.innerHTML = +SCORE_BOARD.innerHTML + points;\r\n        },\r\n        getStyleString: function (obj = {}) {\r\n            return Object.keys(obj).reduce((str, key) => {\r\n                if (!key || !String(key).trim().length) {\r\n                    return str;\r\n                }\r\n                key = String(key).trim();\r\n                let value = obj[key];\r\n                if (!String(value).trim().length) {\r\n                    return str;\r\n                }\r\n                value = String(value).trim();\r\n                return str.concat(` ${key}: ${value};`);\r\n            }, '');\r\n        },\r\n        createHTMLElement: function ({ elementType, innerHTML, attributes = {}, eventListeners = {}, elementNamespace, parent, beforeElement }) {\r\n            if (!parent) {\r\n                parent = UTILS.getDocumentBody();\r\n            }\r\n\r\n            const element = elementNamespace ?\r\n                this.getDocument().createElementNS(elementNamespace, elementType) :\r\n                this.getDocument().createElement(elementType);\r\n\r\n            if (typeof attributes === 'object') {\r\n                Object.keys(attributes).forEach(key => element.setAttribute(key, attributes[key]));\r\n            }\r\n            innerHTML ? element.innerHTML = String(innerHTML) : undefined;\r\n\r\n            if (beforeElement) {\r\n                parent.insertBefore(element, beforeElement);\r\n            } else {\r\n                parent.appendChild(element);\r\n            }\r\n\r\n            if (typeof eventListeners === 'object') {\r\n                Object.keys(eventListeners).forEach(eventName => element.addEventListener(eventName, eventListeners[eventName]));\r\n            }\r\n\r\n            return element;\r\n        },\r\n        LOGGER: {\r\n            log: console.log,\r\n            error: console.error,\r\n            warn: console.warn\r\n        }\r\n    };\r\n\r\n    const { SNAKE_ARENA, PLAY_BUTTON, PAUSE_BUTTON, SCORE_BOARD } = (function init() {\r\n        try {\r\n            UTILS.getDocumentBody().style.fontFamily = 'Candara';\r\n            const gameControlDiv = UTILS.createHTMLElement({\r\n                elementType: 'div',\r\n                attributes: {\r\n                    style: UTILS.getStyleString({\r\n                        display: 'flex',\r\n                        'flex-direction': 'row',\r\n                        'flex-wrap': 'nowrap',\r\n                        width: UTILS.pixelify(CONFIG_ARENA.width),\r\n                        padding: '1% 0%'\r\n                    })\r\n                }\r\n            });\r\n\r\n            const styleString = UTILS.getStyleString({\r\n                padding: '2% 2%',\r\n                'border-radius': '5px',\r\n                flex: '0 1 20%',\r\n                'text-align': 'center',\r\n                'align-self': 'flex-end'\r\n            });\r\n\r\n            const pauseBtn = UTILS.createHTMLElement({\r\n                elementType: 'button',\r\n                parent: gameControlDiv,\r\n                innerHTML: CONFIG_ARENA.pauseButton.text,\r\n                attributes: {\r\n                    id: CONFIG_ARENA.pauseButton.id,\r\n                    style: `${styleString} order: ${CONFIG_ARENA.pauseButton.order}`\r\n                },\r\n                eventListeners: {\r\n                    click: CONFIG_ARENA.pauseButton.clickHandler\r\n                }\r\n            });\r\n\r\n            const playBtn = UTILS.createHTMLElement({\r\n                elementType: 'button',\r\n                parent: gameControlDiv,\r\n                innerHTML: CONFIG_ARENA.resumeButton.text,\r\n                attributes: {\r\n                    id: CONFIG_ARENA.resumeButton.id,\r\n                    style: `${styleString} margin-left: 2%; order: ${CONFIG_ARENA.resumeButton.order}`\r\n                },\r\n                eventListeners: {\r\n                    click: CONFIG_ARENA.resumeButton.clickHandler\r\n                }\r\n            });\r\n\r\n            const arenaContainer = UTILS.createHTMLElement({\r\n                elementType: 'div',\r\n                attributes: {\r\n                    id: 'arena-container',\r\n                    style: UTILS.getStyleString({\r\n                        display: 'flex',\r\n                        'flex-direction': 'cols',\r\n                        'flex-wrap': 'wrap',\r\n                    })\r\n                }\r\n            });\r\n            const canvas = UTILS.createHTMLElement({\r\n                elementNamespace: UTILS.getSvgNamespace(),\r\n                elementType: 'svg',\r\n                attributes: {\r\n                    id: CONFIG_ARENA.id,\r\n                    height: CONFIG_ARENA.height,\r\n                    width: CONFIG_ARENA.width,\r\n                    style: `border: ${UTILS.pixelify(CONFIG_ARENA.borderWidth)} solid ${CONFIG_ARENA.borderColor}`\r\n                },\r\n                parent: arenaContainer\r\n            });\r\n\r\n            const legendContainer = UTILS.createHTMLElement({\r\n                elementType: 'div',\r\n                parent: arenaContainer,\r\n                attributes: {\r\n                    id: 'legend-container',\r\n                    style: UTILS.getStyleString({\r\n                        padding: '2px 2px'\r\n                    })\r\n                }\r\n            });\r\n            UTILS.createHTMLElement({\r\n                parent: legendContainer,\r\n                elementType: 'div',\r\n                innerHTML: 'Speed Powerup'\r\n            });\r\n            UTILS.createHTMLElement({\r\n                parent: legendContainer,\r\n                elementType: 'div',\r\n                innerHTML: 'Bonus 10 points'\r\n            });\r\n            UTILS.createHTMLElement({\r\n                parent: legendContainer,\r\n                elementType: 'div',\r\n                innerHTML: '5 points'\r\n            });\r\n\r\n            const scoreContainer = UTILS.createHTMLElement({\r\n                elementType: 'div',\r\n                innerHTML: 'Your Score: '\r\n            });\r\n            const scoreSpan = UTILS.createHTMLElement({\r\n                elementType: 'span',\r\n                parent: scoreContainer,\r\n                attributes: {\r\n                    id: 'score',\r\n                    style: UTILS.getStyleString({\r\n                        'font-weight': 'bold'\r\n                    })\r\n                },\r\n                innerHTML: '0'\r\n            });\r\n\r\n            return {\r\n                SNAKE_ARENA: canvas,\r\n                PLAY_BUTTON: playBtn,\r\n                PAUSE_BUTTON: pauseBtn,\r\n                SCORE_BOARD: scoreSpan\r\n            };\r\n        } catch (e) {\r\n            UTILS.LOGGER.error(e);\r\n        }\r\n    })();\r\n\r\n    if (!SNAKE_ARENA) {\r\n        return UTILS.showAlert('Sorry. Unable to start the game.');\r\n    }\r\n\r\n    let SNAKE_BONUS_FOOD;\r\n    /**\r\n     * configurations\r\n     */\r\n    const CONFIG = (function (arg) {\r\n        return {\r\n            SNAKE: {\r\n                id: arg.snakeId,\r\n                elemType: 'rect',\r\n                width: arg.snakeSize,\r\n                color: arg.primaryColor,\r\n                length: arg.snakeLength,\r\n                speed: arg.snakeSpeed,\r\n                directionMap: {\r\n                    '37': 'LEFT',\r\n                    '38': 'UP',\r\n                    '39': 'RIGHT',\r\n                    '40': 'DOWN'\r\n                },\r\n                step: 1\r\n            },\r\n            SNAKE_PART: {\r\n                'idPrefix': arg.snakeId + '-part'\r\n            },\r\n            SNAKE_FOOD: {\r\n                'id': arg.snakeFoodId,\r\n                'elemType': 'circle',\r\n                'color': arg.secondaryColor,\r\n                'size': Math.floor(arg.snakeSize / 3),\r\n                'startAfter': 2,\r\n                'limits': {\r\n                    'x': CONFIG_ARENA.limits.x - arg.snakeSize,\r\n                    'y': CONFIG_ARENA.limits.y - arg.snakeSize\r\n                },\r\n                'points': arg.foodPoints\r\n            },\r\n            SNAKE_BONUS_FOOD: {\r\n                'id': arg.snakeBonusFoodId,\r\n                'color': arg.alertColor,\r\n                'elemType': 'circle',\r\n                'size': arg.snakeSize,\r\n                'startAfter': 30,\r\n                'limits': {\r\n                    'x': CONFIG_ARENA.limits.x - (arg.snakeSize * 2),\r\n                    'y': CONFIG_ARENA.limits.y - (arg.snakeSize * 2)\r\n                },\r\n                'points': arg.bonusFoodPoints,\r\n                'duration': 10\r\n            },\r\n            ARENA: {\r\n                center: {\r\n                    x: Math.floor(Math.floor(SNAKE_ARENA.getAttribute('width')) / 2),\r\n                    y: Math.floor(Math.floor(SNAKE_ARENA.getAttribute('height')) / 2)\r\n                }\r\n            }\r\n        };\r\n    })({\r\n        snakeId: 'the-snake',\r\n        snakeFoodId: 'the-snake-food',\r\n        snakeBonusFoodId: 'the-snake-bonus-food',\r\n        snakeSpeed: 20,\r\n        primaryColor: 'black',\r\n        secondaryColor: 'grey',\r\n        alertColor: 'red',\r\n        snakeLength: 1,\r\n        snakeSize: 15,\r\n        foodPoints: 5,\r\n        bonusFoodPoints: 10\r\n    });\r\n    let SNAKE_DIRECTION = 39;\r\n\r\n    /**\r\n     * store the directions given to the snake\r\n     */\r\n    const COMMAND_STACK = (initCommand => {\r\n        const commands = [];\r\n        if (initCommand) {\r\n            commands.push(initCommand);\r\n        }\r\n        return {\r\n            add: function (data) {\r\n                let last = commands[commands.length - 1];\r\n                if (!last) {\r\n                    commands.push(data);\r\n                    return;\r\n                }\r\n                if (last.position.x == data.position.x && last.position.y == data.position.y) {\r\n                    last.direction = data.direction;\r\n                } else {\r\n                    commands.push(data);\r\n                }\r\n            },\r\n            getFirst: function () {\r\n                return commands[0];\r\n            },\r\n            remove: function () {\r\n                commands.shift();\r\n                return;\r\n            },\r\n            clear: function () {\r\n                commands.splice(0, commands.length);\r\n                return;\r\n            },\r\n            hasCommands: function () {\r\n                return commands.length > 0 ? true : false;\r\n            },\r\n            getNextTurn: function (snakePartId) {\r\n                if (typeof SNAKE_DIRECTION_MAP[snakePartId] === 'undefined') {\r\n                    return this.getFirst();\r\n                }\r\n                let turnMadeIndex = commands.findIndex(com => com.id === SNAKE_DIRECTION_MAP[snakePartId]);\r\n                return (turnMadeIndex == commands.length - 1) ? undefined : commands[turnMadeIndex + 1];\r\n            }\r\n        };\r\n    })({\r\n        id: Date.now(),\r\n        direction: SNAKE_DIRECTION,\r\n        position: {\r\n            x: CONFIG.ARENA.center.x,\r\n            y: CONFIG.ARENA.center.y\r\n        }\r\n    });\r\n\r\n    const SNAKE_DIRECTION_MAP = {};\r\n\r\n    const { Snake } = SnakeModule(CONFIG, UTILS);\r\n    const SnakeFoodClass = SnakeFoodModule(CONFIG, UTILS);\r\n    const SnakeFoodBonusClass = SnakeBonusFoodModule(CONFIG, UTILS);\r\n\r\n    class PlaySnakeGame {\r\n        constructor(arena) {\r\n            this.intervals = [];\r\n            this.timers = [];\r\n            this._snake;\r\n            this._snakeFood;\r\n            this._snakeBonusFood;\r\n            this.snakeDirection;\r\n            this.arena = arena;\r\n            this.snakeSpeed = 20;\r\n        }\r\n\r\n        getSnake() {\r\n            if (this._snake instanceof Snake) {\r\n                return this._snake;\r\n            }\r\n            const { direction, position: { x, y } } = COMMAND_STACK.getFirst();\r\n            this.snakeDirection = direction;\r\n            this._snake = new Snake(\r\n                this.arena,\r\n                x,\r\n                y,\r\n                this.snakeDirection,\r\n                this.snakeSpeed\r\n            );\r\n            return this._snake;\r\n        }\r\n\r\n        getSnakeFood() {\r\n            if (this._snakeFood instanceof SnakeFoodClass) {\r\n                return this._snakeFood;\r\n            }\r\n            const { x, y } = SnakeFoodClass.getNextFoodPosition();\r\n            this._snakeFood = new SnakeFoodClass(this.arena, x, y);\r\n            return this._snakeFood;\r\n        }\r\n\r\n        getSnakeBonusFood() {\r\n            if (this._snakeBonusFood instanceof SnakeFoodBonusClass) {\r\n                return this._snakeBonusFood;\r\n            }\r\n            const { x, y } = SnakeFoodBonusClass.getNextFoodPosition();\r\n            this._snakeBonusFood = new SnakeFoodBonusClass(\r\n                this.arena, x, y\r\n            );\r\n            return this._snakeBonusFood;\r\n        }\r\n\r\n        start() {\r\n            try {\r\n                this.getSnake();\r\n                const food = this.getSnakeFood();\r\n                setTimeout(CONFIG.SNAKE_FOOD.startAfter * 1000, food);\r\n                const bonusFood = this.getSnakeBonusFood();\r\n                this.intervals.push(bonusFood.startBonusFood());\r\n                this.setButtonListeners();\r\n                this.intervals.push(this.getSnake().startSnake());\r\n            } catch (error) {\r\n                UTILS.showAlert(ERROR_MESSAGES.START_GAME);\r\n            }\r\n        }\r\n\r\n        pause() {\r\n\r\n        }\r\n\r\n        async stop() {\r\n            this._snake = null;\r\n            UTILS.getWindow().clearInterval(this.getSnake().intervalId);\r\n            const { intervalId: bonusFoodInterval } = this.getSnakeBonusFood();\r\n            UTILS.getWindow().clearInterval(bonusFoodInterval);\r\n            this._snakeFood = null;\r\n            this._snakeBonusFood = null;\r\n            UTILS.getWindow().alert('GAME OVER\\nYou Scored ' + SCORE_BOARD.innerHTML + ' points.');\r\n        }\r\n\r\n        async resume() {\r\n            const bonusFoodIntervalId = this.getSnakeBonusFood().startBonusFood();\r\n            this.intervals.push(bonusFoodIntervalId);\r\n            this.intervals.push(this.getSnake().startSnake());\r\n            LOGGER.log('game resumed');\r\n        }\r\n\r\n        setButtonListeners() {\r\n            UTILS.getWindow().addEventListener('unload', this.stop);\r\n            UTILS.getDocument().addEventListener('keydown', event => {\r\n                /** listen only for direction keys */\r\n                if (CONFIG_ARENA.supportedKeys.indexOf(event.keyCode) === -1) {\r\n                    return;\r\n                }\r\n                /**\r\n                 * the new direction should not be the current direction \r\n                 * or the opposite direction.\r\n                 */\r\n                if (SNAKE_DIRECTION == event.keyCode &&\r\n                    event.keyCode == CONFIG_ARENA.keyConfig[String(SNAKE_DIRECTION)].reverse) {\r\n                    return;\r\n                }\r\n                SNAKE_DIRECTION = event.keyCode;\r\n                this.snakeDirection = event.keyCode;\r\n                this.getSnake().currentDirection = this.snakeDirection;\r\n                COMMAND_STACK.add({\r\n                    id: Date.now(),\r\n                    direction: event.keyCode,\r\n                    position: {\r\n                        x: UTILS.getSnake().head.x,\r\n                        y: UTILS.getSnake().head.y\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        increaseSnakeSpeed() {\r\n            UTILS.getWindow().clearInterval(this.getSnake().intervalId);\r\n            startSnake(CONFIG.SNAKE.speed - UTILS.getSnake().length * 50);\r\n        }\r\n    }\r\n\r\n    const game = new PlaySnakeGame(SNAKE_ARENA);\r\n\r\n    game.start();\r\n};\r\n\r\nPLAY_SNAKE();","export default function (config, utils) {\r\n    return class SnakeFoodBonus {\r\n        constructor(arena, cx, cy, color = config.SNAKE_BONUS_FOOD.color, size = config.SNAKE_BONUS_FOOD.size) {\r\n            this.element = utils.createHTMLElement({\r\n                elementNamespace: utils.getSvgNamespace(),\r\n                elementType: config.SNAKE_BONUS_FOOD.elemType,\r\n                beforeElement: utils.getSnake().head.element,\r\n                parent: utils.getArena(),\r\n                attributes: {\r\n                    id: config.SNAKE_BONUS_FOOD.id,\r\n                    cx,\r\n                    cy,\r\n                    r: size,\r\n                    fill: color\r\n                }\r\n            });\r\n            this.arena = arena;\r\n            [this.x2, this.y2] = [cx + (config.SNAKE_BONUS_FOOD.size - 1), cy + (config.SNAKE_BONUS_FOOD.size - 1)];\r\n            this.intervalId;\r\n        }\r\n        startBonusFood() {\r\n            this.intervalId = setInterval(\r\n                () => { this.drop(); },\r\n                config.SNAKE_BONUS_FOOD.startAfter * 1000\r\n            );\r\n            return this.intervalId;\r\n        }\r\n        get x() {\r\n            return parseInt(this.element.getAttribute('cx'));\r\n        }\r\n        set x(value) {\r\n            this.element.setAttribute('cx', Math.floor(value));\r\n        }\r\n        get y() {\r\n            return parseInt(this.element.getAttribute('cy'));\r\n        }\r\n        set y(value) {\r\n            this.element.setAttribute('cy', Math.floor(value));\r\n        }\r\n        static getNextFoodPosition() {\r\n            function getRandomX() {\r\n                return Math.floor(Math.random() * (config.SNAKE_BONUS_FOOD.limits.x - config.SNAKE_BONUS_FOOD.size)) + utils.getArenaConfig().borderWidth + 1;\r\n            }\r\n            function getRandomY() {\r\n                return Math.floor(Math.random() * (config.SNAKE_BONUS_FOOD.limits.y - config.SNAKE_BONUS_FOOD.size)) + utils.getArenaConfig().borderWidth + 1;\r\n            }\r\n            // return new Promise(function (resolve, reject) {\r\n            let _x, _y;\r\n            const snakeWidth = config.SNAKE.width;\r\n            // let interval;\r\n            do {\r\n                [_x, _y] = [getRandomX(), getRandomY()];\r\n            } while (_x % snakeWidth !== 0 && _y % snakeWidth !== 0);\r\n            return { x: _x + 2, y: _y + 2 };\r\n            // interval = setInterval(function (multipleOf, res, rej) {\r\n            //     try {\r\n            //         if (_x % multipleOf === 0 && _y % multipleOf === 0) {\r\n            //             utils.getWindow().clearInterval(interval);\r\n            //             res({\r\n            //                 x: _x + 2, y: _y + 2\r\n            //             });\r\n            //         } else {\r\n            //             [_x, _y] = [getRandomX(), getRandomY()];\r\n            //         }\r\n            //     } catch (e) {\r\n            //         reject(e);\r\n            //     }\r\n\r\n            // }, 0, config.SNAKE.width, resolve, reject);\r\n            // });\r\n        }\r\n        async drop() {\r\n            const { x, y } = await SnakeFoodBonus.getNextFoodPosition();\r\n            this.x = x;\r\n            this.y = y;\r\n            // start timer to hide bonus food\r\n            setTimeout(() => { this.hide(); }, config.SNAKE_BONUS_FOOD.duration * 1000);\r\n        }\r\n        hide() {\r\n            this.x = -100;\r\n            this.y = -100;\r\n        }\r\n    }\r\n};","export default function (config, utils) {\r\n    return class SnakeFood {\r\n        constructor(arena, cx, cy, color = config.SNAKE_FOOD.color, size = config.SNAKE_FOOD.size) {\r\n\r\n            this.element = utils.createHTMLElement({\r\n                elementType: config.SNAKE_FOOD.elemType,\r\n                elementNamespace: utils.getSvgNamespace(),\r\n                attributes: {\r\n                    id: config.SNAKE_FOOD.id,\r\n                    cx,\r\n                    cy,\r\n                    r: size,\r\n                    fill: color\r\n                },\r\n                parent: utils.getArena(),\r\n                beforeElement: utils.getSnake().head.element\r\n            });\r\n            this.arena = arena;\r\n            [this.x2, this.y2] = [cx + (config.SNAKE_FOOD.size - 1), cy + (config.SNAKE_FOOD.size - 1)];\r\n        }\r\n        static getNextFoodPosition() {\r\n            function getRandomX() {\r\n                return Math.floor(Math.random() * (config.SNAKE_FOOD.limits.x - config.SNAKE_FOOD.size)) + utils.getArenaConfig().borderWidth + 1;\r\n            }\r\n            function getRandomY() {\r\n                return Math.floor(Math.random() * (config.SNAKE_FOOD.limits.y - config.SNAKE_FOOD.size)) + utils.getArenaConfig().borderWidth + 1;\r\n            }\r\n            let _x, _y;\r\n            const snakeWidth = config.SNAKE.width;\r\n            do {\r\n                [_x, _y] = [getRandomX(), getRandomY()];\r\n            } while (_x % snakeWidth !== 0 && _y % snakeWidth !== 0);\r\n            return {\r\n                x: _x + 2,\r\n                y: _y + 2\r\n            };\r\n            // return new Promise((resolve, reject) => {\r\n            //     let [_x, _y] = [getRandomX(), getRandomY()];\r\n            //     let interval;\r\n            //     interval = setInterval(function (multipleOf, res, rej) {\r\n            //         try {\r\n            //             if (_x % multipleOf === 0 && _y % multipleOf === 0) {\r\n            //                 utils.getWindow().clearInterval(interval);\r\n            //                 res({\r\n            //                     x: _x + 2,\r\n            //                     y: _y + 2\r\n            //                 });\r\n            //             } else {\r\n            //                 [_x, _y] = [getRandomX(), getRandomY()];\r\n            //             }\r\n            //         } catch (e) {\r\n            //             reject(e);\r\n            //         }\r\n\r\n            //     }, 0, config.SNAKE.width, resolve, reject);\r\n            // });\r\n        }\r\n        get x() {\r\n            return parseInt(this.element.getAttribute('cx'));\r\n        }\r\n        set x(value) {\r\n            this.element.setAttribute('cx', Math.floor(value));\r\n        }\r\n        get y() {\r\n            return parseInt(this.element.getAttribute('cy'));\r\n        }\r\n        set y(value) {\r\n            this.element.setAttribute('cy', Math.floor(value));\r\n        }\r\n        drop() {\r\n            const { x, y } = SnakeFood.getNextFoodPosition();\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n        hide() {\r\n            this.x = -10;\r\n            this.y = -10;\r\n        }\r\n    }\r\n};","export default function (config, utils) {\r\n\r\n    class Snake {\r\n        constructor(arena, startX, startY, direction, speed, color = config.SNAKE.color) {\r\n            this.length = 1;\r\n            this.head = new SnakePart(arena, startX, startY, direction, this.length, color);\r\n            this.tail = this.head;\r\n            this.arena = arena;\r\n            this.speed = speed;\r\n            this.UP = function () {\r\n                this.move(0, config.SNAKE.step * -1);\r\n            };\r\n            this.DOWN = function () {\r\n                this.move(0, config.SNAKE.step);\r\n            };\r\n            this.RIGHT = function () {\r\n                this.move(config.SNAKE.step, 0);\r\n            };\r\n            this.LEFT = function () {\r\n                this.move(config.SNAKE.step * -1, 0);\r\n            };\r\n            this.turningPoints = [];\r\n            this.intervalId;\r\n            this.currentDirection = direction;\r\n        }\r\n        startSnake() {\r\n            this.intervalId = setInterval(() => {\r\n                this.changeDirection(this.currentDirection);\r\n                this.start();\r\n            }, this.speed);\r\n            return this.intervalId;\r\n        }\r\n        changeDirection(newDirection) {\r\n            this.head.direction = newDirection;\r\n        }\r\n        /**\r\n         * adds a snake part at the tail\r\n         * @param {function} next a callback\r\n         * @returns undefined\r\n         */\r\n        grow(next) {\r\n            const { x, y } = this.tail.getXYOfNextPart();\r\n            this.length += 1;\r\n            const newPart = new SnakePart(this.arena, x, y, this.tail.direction, this.length, this.tail.color);\r\n            this.tail.next = newPart;\r\n            newPart.prev = this.tail;\r\n            this.tail = newPart;\r\n            utils.getPositionUpdater().addObserver(this.tail);\r\n            utils.incrementScore(config.SNAKE_FOOD.points);\r\n            // drop food pellet\r\n            if (typeof next === 'function') {\r\n                next();\r\n            }\r\n        }\r\n        changeColor(colour) {\r\n            let _part = this.head;\r\n            while (_part.next !== null) {\r\n                change(_part, colour);\r\n                _part = _part.next;\r\n            }\r\n\r\n            function change(_part, clr) {\r\n                setTimeout(() => {\r\n                    _part.color = clr;\r\n                }, 0);\r\n            }\r\n        }\r\n        start() {\r\n            this[config.SNAKE.directionMap[String(this.head.direction)]]();\r\n        }\r\n        isEatingFood() {\r\n            const food = utils.getSnakeFood();\r\n            const { x: foodX, y: foodY } = food;\r\n            if (this.head.x < foodX\r\n                && foodX < this.head.x2\r\n                && this.head.y < foodY\r\n                && foodY < this.head.y2) {\r\n                food.hide();\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        isEatingBonusFood() {\r\n            const bonusFoodSize = config.SNAKE_BONUS_FOOD.size;\r\n            const head = this.head;\r\n            const { x: bonusFoodX, y: bonusFoodY } = utils.getSnakeBonusFood();\r\n            let x1 = bonusFoodX - bonusFoodSize - 1;\r\n            let x2 = bonusFoodX + bonusFoodSize - 1;\r\n            let y1 = bonusFoodY - bonusFoodSize - 1;\r\n            let y2 = bonusFoodY + bonusFoodSize - 1;\r\n            if (x1 < head.x && head.x < x2 && y1 < head.y && head.y < y2) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        move(xvalue, yvalue) {\r\n            let _part = this.head;\r\n            let [_part_x_pos, _part_y_pos] = [_part.x, _part.y];\r\n            let { x: nextX, y: nextY } = SnakePart.checkBoundaryPosition(_part.direction, {\r\n                'x': _part_x_pos + xvalue,\r\n                'y': _part_y_pos + yvalue\r\n            });\r\n            const isGoingToEatSelf = this.isEatingItself();\r\n            if (isGoingToEatSelf) {\r\n                utils.LOGGER.warn('You ate yourself');\r\n                stopTheGame();\r\n                return;\r\n            }\r\n            _part.x = nextX;\r\n            _part.y = nextY;\r\n            const isEatingFood = this.isEatingFood();\r\n            const isEatingBonusFood = this.isEatingBonusFood();\r\n            if (isEatingBonusFood) {\r\n                utils.getSnakeBonusFood().hide();\r\n                utils.incrementScore(config.SNAKE_BONUS_FOOD.points);\r\n            }\r\n            this.moveAllParts(isEatingFood);\r\n        }\r\n        moveAllParts(foodEaten) {\r\n            if (this.length === 1) {\r\n                utils.getDirectionCommands().clear();\r\n            }\r\n            utils.getPositionUpdater().notify(foodEaten);\r\n        }\r\n        /**\r\n         * @returns {boolean} indicates wether the snake is going to eat itself\r\n         */\r\n        isEatingItself() {\r\n            let isGoingToEat = false;\r\n            let nextPart = this.head.next;\r\n            let snakeDirection = this.head.direction;\r\n            while (nextPart !== null) {\r\n                // check for tail node and nodes which are traveliing in different direction than the head\r\n                if (nextPart.direction !== snakeDirection || nextPart.id === this.tail.id) {\r\n                    switch (snakeDirection) {\r\n                        case 37:\r\n                            if (this.head.y === nextPart.y && this.head.x > nextPart.x && this.head.x <= nextPart.x2) {\r\n                                isGoingToEat = true;\r\n                            }\r\n                            break;\r\n                        case 38:\r\n                            if (this.head.x === nextPart.x && this.head.y > nextPart.y && this.head.y <= nextPart.y2) {\r\n                                isGoingToEat = true;\r\n                            }\r\n                            break;\r\n                        case 39:\r\n                            if (this.head.y === nextPart.y && this.head.x2 < nextPart.x2 && this.head.x2 >= nextPart.x) {\r\n                                isGoingToEat = true;\r\n                            }\r\n                            break;\r\n                        case 40:\r\n                            if (this.head.x === nextPart.x && this.head.y2 < nextPart.y2 && this.head.y2 >= nextPart.y) {\r\n                                isGoingToEat = true;\r\n                            }\r\n                            break;\r\n                    }\r\n                    if (isGoingToEat) {\r\n                        break;\r\n                    }\r\n                }\r\n                nextPart = nextPart.next;\r\n            }\r\n            if (isGoingToEat) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n\r\n    class SnakePart {\r\n        constructor(arena, x, y, dirx, partNumber, color) {\r\n            this.id = `${config.SNAKE.id}-part${partNumber}`;\r\n            this.direction = dirx;\r\n            this.element = utils.createHTMLElement({\r\n                elementNamespace: utils.getSvgNamespace(),\r\n                elementType: config.SNAKE.elemType,\r\n                attributes: {\r\n                    id: this.id,\r\n                    tabIndex: partNumber,\r\n                    x,\r\n                    y,\r\n                    rx: config.SNAKE.width,\r\n                    ry: config.SNAKE.width,\r\n                    fill: color,\r\n                    width: utils.pixelify(config.SNAKE.width),\r\n                    height: utils.pixelify(config.SNAKE.width)\r\n                },\r\n                parent: arena\r\n            });\r\n            this.color = color;\r\n            this.next = null;\r\n            this.prev = null;\r\n        }\r\n        isSnakeHead() {\r\n            return this.id === config.SNAKE.id;\r\n        }\r\n        get x() {\r\n            return parseInt(this.element.getAttribute('x'));\r\n        }\r\n        set x(value) {\r\n            this.element.setAttribute('x', Math.floor(value));\r\n        }\r\n        get y() {\r\n            return parseInt(this.element.getAttribute('y'));\r\n        }\r\n        set y(value) {\r\n            this.element.setAttribute('y', Math.floor(value));\r\n        }\r\n        get x2() {\r\n            return this.x + (config.SNAKE.width - 1);\r\n        }\r\n        get y2() {\r\n            return this.y + (config.SNAKE.width - 1);\r\n        }\r\n        isTail() {\r\n            return this.id === utils.getSnake().tail.id;\r\n        }\r\n\t\t/**\r\n\t\t * method calculates the next coordinates for a part on each step\r\n\t\t */\r\n        nextXY() {\r\n            let nextPosition = {\r\n                'x': this.x, 'y': this.y\r\n            }\r\n            switch (this.direction) {\r\n                case 37:\r\n                    nextPosition.x -= config.SNAKE.step;\r\n                    break;\r\n                case 38:\r\n                    nextPosition.y -= config.SNAKE.step;\r\n                    break;\r\n                case 39:\r\n                    nextPosition.x += config.SNAKE.step;\r\n                    break;\r\n                case 40:\r\n                    nextPosition.y += config.SNAKE.step;\r\n                    break;\r\n            }\r\n            nextPosition = SnakePart.checkBoundaryPosition(this.direction, nextPosition);\r\n            this.x = nextPosition.x;\r\n            this.y = nextPosition.y;\r\n            if (utils.getDirectionCommands().hasCommands()) {\r\n                let _command = utils.getDirectionCommands().getNextTurn(this.id);\r\n                if (_command && _command.position.x == this.x && _command.position.y == this.y) {\r\n                    this.direction = _command.direction;\r\n                    (utils.getSnakeDirectionMap())[this.id] = _command.id;\r\n                    if (this.isTail()) {\r\n                        utils.getDirectionCommands().remove();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        getXYOfNextPart() {\r\n            let [_x, _y] = [this.x, this.y];\r\n            switch (this.direction) {\r\n                case 37:\r\n                    _x += config.SNAKE.width;\r\n                    break;\r\n                case 38:\r\n                    _y += config.SNAKE.width;\r\n                    break;\r\n                case 39:\r\n                    _x -= config.SNAKE.width;\r\n                    break;\r\n                case 40:\r\n                    _y -= config.SNAKE.width;\r\n                    break;\r\n            }\r\n            return { x: _x, y: _y };\r\n        }\r\n\t\t/**\r\n\t\t * returns new coordinates if the snake part is going out of bounds.\r\n\t\t * \r\n\t\t * @param {number} direction the current direction of the snake part.\r\n\t\t * @param {object} position coordinates of the next step.\r\n\t\t */\r\n        static checkBoundaryPosition(direction, position) {\r\n            switch (direction) {\r\n                case 37:\r\n                    if (position.x < utils.getArenaConfig().borderWidth) {\r\n                        position.x = utils.getArenaConfig().limits.x - config.SNAKE.width;\r\n                    }\r\n                    break;\r\n                case 38:\r\n                    if (position.y < utils.getArenaConfig().borderWidth) {\r\n                        position.y = utils.getArenaConfig().limits.y - config.SNAKE.width;\r\n                    }\r\n                    break;\r\n                case 39:\r\n                    if (position.x + config.SNAKE.width > utils.getArenaConfig().limits.x) {\r\n                        position.x = utils.getArenaConfig().borderWidth;\r\n                    }\r\n                    break;\r\n                case 40:\r\n                    if (position.y + config.SNAKE.width > utils.getArenaConfig().limits.y) {\r\n                        position.y = utils.getArenaConfig().borderWidth;\r\n                    }\r\n                    break;\r\n            }\r\n            return position;\r\n        }\r\n    }\r\n\r\n    return {\r\n        SnakePart,\r\n        Snake\r\n    };\r\n};"],"sourceRoot":""}